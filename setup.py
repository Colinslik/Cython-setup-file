# coding: utf-8

import glob
import os
from distutils.command.clean import clean
from distutils.core import setup
from setuptools.extension import Extension
import py_compile

try:
    from Cython.Distutils import build_ext
except (ImportError, ImportWarning):
    print("Import Cython failed. Is Cython not installed?")
    raise

Project_Name = 'fedemeter'
Project_PKG_Path = 'apiserver'
Exclusion_list = ["__init__.py", "alameter_api.py"]
Pyc_list = ["alameter_api.py", "datahubcli.py"]


def _searching_dir(current_dir, extension, files=list(),
                   exclusive_list=None, inclusive_list=None):
    """ Create a list of all files to be compiled """
    for file_name in os.listdir(current_dir):
        if exclusive_list and file_name in exclusive_list:
            continue
        file_path = os.path.join(current_dir, file_name)
        if os.path.isfile(file_path) and file_path.endswith(extension) and (
                not inclusive_list or file_name in inclusive_list):
            files.append(file_path)
        elif os.path.isdir(file_path):
            _searching_dir(
                file_path,
                extension,
                files,
                exclusive_list,
                inclusive_list)

    return files


def _make_extension(ext_path, only_filename=False, includes=list()):
    """Generate an Extension object from its dotted name

    :param ext_path:
    :param only_filename:
    :param includes: Including path
    :return:
    """
    if only_filename is True:
        ext_path = os.path.basename(ext_path)

    return Extension(
        (ext_path.replace(os.path.sep, '.'))[:-3],
        [ext_path],
        include_dirs=includes + ['.'],
        # adding the '.' to include_dirs is CRUCIAL!!
        # extra_compile_args = ["-O3", "-Wall"],
        # extra_link_args = ['-g'],
        # libraries = ["dv",],
    )


def _purge(pattern):
    for path in glob.glob(pattern):
        if os.path.exists(path):
            os.remove(path)


class CleanAll(clean):
    def run(self):
        # Clean build
        clean.run(self)

        # Clean *.c, *.so generated by py file
        for file_path in py_modules + pyc_modules:
            _purge(file_path[:-3] + "*.c")
            _purge(file_path[:-3] + '*.py')


if __name__ == '__main__':

    # build up the set of Extension objects
    ext_modules = []
    py_modules = _searching_dir(
        Project_PKG_Path,
        ".py",
        [],
        exclusive_list=Exclusion_list)
    for name in py_modules:
        ext_modules.append(_make_extension(name))
    pyc_modules = _searching_dir(
        Project_PKG_Path,
        ".py",
        [],
        inclusive_list=Pyc_list)
    for path in pyc_modules:
        py_compile.compile(path, path + "c")

    setup(
        name=Project_Name,
        version="0.2.0",
        cmdclass={'build_ext': build_ext, 'cleanall': CleanAll},
        ext_modules=ext_modules,
    )
